/* eslint-disable */
// These types will be used in the segment app UI for autocomplete
// Generated from: @segment/analytics-signals-runtime@2.0.0
// Built as text so they do not cause global scope pollution for packages importing unrelated modules

 declare interface AppContext {
    name: string;
    version: string;
    build: string;
    namespace: string;
}

 declare interface BaseSignal {
    type: string;
    anonymousId: ID;
    timestamp: string;
    index: any;
    data: any;
    context: Context;
}

 declare interface Context {
    /**
     * Information about the app that generated the signal.
     * This only exists in the mobile runtime.
     */
    app?: AppContext;
    library: LibraryContext;
    signalsRuntime: string;
}

 declare type EventType = 'track' | 'page' | 'screen' | 'identify' | 'group' | 'alias';

 declare type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS';

 declare type ID = string | null | undefined;

declare interface InstrumentationData {
    type: EventType;
    rawEvent: any;
}

declare type InstrumentationSignal = RawSignal<'instrumentation', InstrumentationData>;

declare interface InteractionData {
    eventType: string;
    target: {
        component: string;
        title: string;
        data: any;
    };
}

declare type InteractionSignal = RawSignal<'interaction', InteractionData>;

 declare interface LibraryContext {
    name: string;
    version: string;
}

declare interface LocalData {
    action: LocalDataAction;
    identifier: string;
    data: string;
}

 declare type LocalDataAction = 'created' | 'read' | 'updated' | 'deleted' | 'undefined';

declare type LocalDataSignal = RawSignal<'localData', LocalData>;

 declare class MobileSignalsRuntime extends SignalsRuntime<Signal> {
    private _signalCounter;
    constructor(signals?: Signal[]);
    _add: (signal: Signal) => void;
    _getNextIndex: () => number;
}

declare interface NavigationData {
    previousScreen: String;
    currentScreen: string;
}

declare type NavigationSignal = RawSignal<'navigation', NavigationData>;

 declare type NetworkAction = 'request' | 'response';

declare interface NetworkData {
    action: NetworkAction;
    url: string;
    body: any;
    contentType: string;
    method: HTTPMethod;
    status: number;
    ok: boolean;
    requestId: string;
}

declare type NetworkSignal = RawSignal<'network', NetworkData>;

 declare interface RawSignal<T extends SignalType, Data> extends BaseSignal {
    type: T;
    data: Data;
    index: number;
}

 declare interface SegmentEvent {
    /**
     * @example 'track' | 'page' | 'screen' | 'identify' | 'group' | 'alias'
     */
    type: string;
    [key: string]: unknown;
}

 declare type Signal = InteractionSignal | NavigationSignal | NetworkSignal | LocalDataSignal | InstrumentationSignal | UserDefinedSignal;

 declare type SignalOfType<AllSignals extends BaseSignal, SignalType extends AllSignals['type']> = AllSignals & {
    type: SignalType;
};

 declare const signals: MobileSignalsRuntime;

/**
 * Base class that provides runtime utilities for signals.
 */
declare abstract class SignalsRuntime<Signal extends BaseSignal = BaseSignal> {
    signalBuffer: Signal[];
    protected _maxBufferSize: number;
    constructor(signals?: Signal[]);
    /**
     * Finds a signal of a specific type from a given signal.
     *
     * SignalType - The type of the signal to find.
     * @param fromSignal - The signal to search from.
     * @param signalType - The type of the signal to find.
     * @param predicate - Optional predicate function to filter the signals.
     * @returns The found signal of the specified type, or undefined if not found.
     */
    find: <SignalType extends Signal["type"]>(fromSignal: Signal, signalType: SignalType, predicate?: (signal: SignalOfType<Signal, SignalType>) => boolean) => SignalOfType<Signal, SignalType> | undefined;
    /**
     * Filters signals of a specific type from a given signal.
     * SignalType - The type of the signals to filter.
     * @param fromSignal - The signal to search from.
     * @param signalType - The type of the signals to filter.
     * @param predicate - Optional predicate function to filter the signals.
     * @returns An array of signals of the specified type.
     */
    filter: <SignalType extends Signal["type"]>(fromSignal: Signal, signalType: SignalType, predicate?: (signal: SignalOfType<Signal, SignalType>) => boolean) => SignalOfType<Signal, SignalType>[];
}

 declare type SignalType = 'interaction' | 'navigation' | 'network' | 'localData' | 'instrumentation' | 'userDefined';

declare type UserDefinedSignal = RawSignal<'userDefined', any>;

