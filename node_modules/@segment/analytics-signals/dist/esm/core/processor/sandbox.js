import { WebSignalsRuntime } from "@segment/analytics-signals-runtime";
import { getRuntimeCode } from "@segment/analytics-signals-runtime";
import { loadScript } from "../../lib/load-script";
import { logger } from "../../lib/logger";
import { replaceBaseUrl } from "../../lib/replace-base-url";
import { createWorkerBox } from "../../lib/workerbox";
import { polyfills } from "./polyfills";
import { AnalyticsRuntime, } from "./sandbox-analytics-runtime";
class JavascriptSandbox {
    constructor() {
        this.workerbox = createWorkerBox();
    }
    async run(fn, scope) {
        try {
            const wb = await this.workerbox;
            await wb.run(fn, scope);
        }
        catch (err) {
            console.error("processSignal() error in sandbox", err, {
                fn,
            });
        }
    }
    async destroy() {
        const wb = await this.workerbox;
        await wb.destroy();
    }
}
export const normalizeEdgeFunctionURL = (functionHost, edgeFnDownloadURL) => {
    if (functionHost && edgeFnDownloadURL) {
        replaceBaseUrl(edgeFnDownloadURL, `https://${functionHost}`);
    }
    else {
        return edgeFnDownloadURL;
    }
};
const consoleWarnProcessSignal = () => console.warn("processSignal is not defined - have you set up auto-instrumentation on app.segment.com?");
export class IframeSandboxSettings {
    constructor(settings) {
        const fetch = settings.edgeFnFetchClient ?? globalThis.fetch;
        let processSignalNormalized = Promise.resolve(`globalThis.processSignal = function() {}`);
        if (settings.processSignal) {
            processSignalNormalized = Promise.resolve(settings.processSignal).then((str) => `globalThis.processSignal = ${str}`);
        }
        else if (settings.edgeFnDownloadURL) {
            processSignalNormalized = fetch(settings.edgeFnDownloadURL).then((res) => res.text());
        }
        else {
            consoleWarnProcessSignal();
        }
        this.processSignal = processSignalNormalized;
    }
}
export class WorkerSandbox {
    constructor(settings) {
        this.settings = settings;
        this.jsSandbox = new JavascriptSandbox();
    }
    async execute(signal, signals) {
        const analytics = new AnalyticsRuntime();
        const scope = {
            analytics,
        };
        logger.debug("processing signal", { signal, scope, signals });
        const code = [
            polyfills,
            await this.settings.processSignal,
            getRuntimeCode(),
            `signals.signalBuffer = ${JSON.stringify(signals)};`,
            "try { processSignal(" +
                JSON.stringify(signal) +
                ', { analytics, signals }); } catch(err) { console.error("Process signal failed.", err); }',
        ].join("\n");
        await this.jsSandbox.run(code, scope);
        const calls = analytics.getCalls();
        return calls;
    }
    destroy() {
        void this.jsSandbox.destroy();
    }
}
// ProcessSignal unfortunately uses globals. This should change.
// For now, we are setting up the globals between each invocation
const processWithGlobalScopeExecutionEnv = (signal, signalBuffer) => {
    const g = globalThis;
    const processSignal = g["processSignal"];
    if (typeof processSignal == "undefined") {
        consoleWarnProcessSignal();
        return undefined;
    }
    // processSignal expects a global called `signals` -- of course, there can local variable naming conflict on the client, which is why globals were a bad idea.
    const analytics = new AnalyticsRuntime();
    const signals = new WebSignalsRuntime(signalBuffer);
    const originalAnalytics = g.analytics;
    if (originalAnalytics instanceof AnalyticsRuntime) {
        throw new Error("Invariant: analytics variable was not properly restored on the previous execution. This indicates a concurrency bug");
    }
    const originalSignals = g.signals;
    try {
        g["analytics"] = analytics;
        g["signals"] = signals;
        processSignal(signal, {
            // we eventually want to get rid of globals and processSignal just uses local variables.
            // TODO: update processSignal generator to accept params like these for web (mobile currently uses globals for their architecture -- can be changed but hard).
            analytics: analytics,
            signals: signals,
            // constants
        });
    }
    finally {
        // restore globals
        g["analytics"] = originalAnalytics;
        g["signals"] = originalSignals;
    }
    return analytics.getCalls();
};
export class GlobalScopeSandbox {
    constructor(settings) {
        logger.debug("Initializing global scope sandbox");
        this.htmlScriptLoaded = loadScript(settings.edgeFnDownloadURL);
    }
    async execute(signal, signals) {
        await this.htmlScriptLoaded;
        return processWithGlobalScopeExecutionEnv(signal, signals);
    }
    destroy() { }
}
export class NoopSandbox {
    execute(_signal, _signals) {
        return Promise.resolve(undefined);
    }
    destroy() { }
}
//# sourceMappingURL=sandbox.js.map