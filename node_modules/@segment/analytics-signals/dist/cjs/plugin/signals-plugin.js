"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignalsPlugin = void 0;
const signals_1 = require("../core/signals");
const version_1 = require("../generated/version");
const assert_browser_env_1 = require("../lib/assert-browser-env");
const logger_1 = require("../lib/logger");
const factories_1 = require("../types/factories");
class SignalsPlugin {
    constructor(settings = {}) {
        this.type = "utility";
        this.name = "SignalsPlugin";
        this.version = version_1.version;
        (0, assert_browser_env_1.assertBrowserEnv)();
        // assign to window.SegmentSignalsPlugin for debugging purposes (e.g window.SegmentSignalsPlugin.debug())
        Object.assign(window, { SegmentSignalsPlugin: this });
        this.signals = new signals_1.Signals({
            ...settings,
            processSignal: typeof settings.processSignal === "function"
                ? settings.processSignal.toString()
                : settings.processSignal,
        });
        logger_1.logger.debug(`SignalsPlugin v${version_1.version} initializing`, {
            settings,
        });
    }
    isLoaded() {
        return true;
    }
    async load(_ctx, analytics) {
        try {
            await this.signals.start(analytics);
            logger_1.logger.debug("SignalsPlugin loaded");
        }
        catch (err) {
            console.error(err);
        }
    }
    stop() {
        return this.signals.stop();
    }
    onSignal(cb) {
        this.signals.signalEmitter.subscribe(cb);
        return this;
    }
    addSignal(data) {
        this.signals.signalEmitter.emit((0, factories_1.createUserDefinedSignal)(data));
        return this;
    }
    /**
     * Enable redaction and disable ingestion of signals. Also, logs signals to the console.
     */
    debug(...args) {
        this.signals.debug(...args);
        return this;
    }
}
exports.SignalsPlugin = SignalsPlugin;
//# sourceMappingURL=signals-plugin.js.map