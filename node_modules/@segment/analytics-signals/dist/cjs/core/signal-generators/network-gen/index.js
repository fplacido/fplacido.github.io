"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkGenerator = void 0;
const logger_1 = require("../../../lib/logger");
const factories_1 = require("../../../types/factories");
const helpers_1 = require("./helpers");
const network_interceptor_1 = require("./network-interceptor");
class NetworkGenerator {
    constructor() {
        this.id = "network";
        this.interceptor = new network_interceptor_1.NetworkInterceptor();
        /* List of all signal request IDs that have been emitted */
        this.emittedRequestIds = [];
    }
    register(emitter) {
        const handleRequest = (rq) => {
            if (!rq.url) {
                return;
            }
            const body = typeof rq.body === "string" ? (0, helpers_1.tryJSONParse)(rq.body) : null;
            this.emittedRequestIds.push(rq.id);
            emitter.emit((0, factories_1.createNetworkSignal)({
                action: "request",
                url: rq.url,
                method: rq.method || "GET",
                body,
                contentType: rq.headers?.get("content-type") || "",
                requestId: rq.id,
            }));
        };
        const handleResponse = async (rs) => {
            const isSuccessWithNonJSONResponse = rs.ok &&
                rs.responseType !== "json" &&
                !(0, helpers_1.containsJSONContentType)(rs.headers);
            const isErrorButRequestNeverEmittted = !rs.ok && !this.emittedRequestIds.includes(rs.req.id);
            if (isSuccessWithNonJSONResponse || isErrorButRequestNeverEmittted) {
                return;
            }
            const url = rs.url;
            if (!url) {
                return;
            }
            const data = await rs.body();
            emitter.emit((0, factories_1.createNetworkSignal)({
                action: "response",
                url,
                body: data,
                ok: rs.ok,
                status: rs.status,
                contentType: rs.headers.get("content-type") || "",
                requestId: rs.req.id,
            }));
        };
        this.interceptor.addInterceptors(handleRequest, handleResponse);
        return () => {
            this.interceptor.cleanup();
            logger_1.logger.debug("Removing fetch interceptor");
        };
    }
}
exports.NetworkGenerator = NetworkGenerator;
//# sourceMappingURL=index.js.map