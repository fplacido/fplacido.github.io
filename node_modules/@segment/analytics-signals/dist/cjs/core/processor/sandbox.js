"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoopSandbox = exports.GlobalScopeSandbox = exports.WorkerSandbox = exports.IframeSandboxSettings = exports.normalizeEdgeFunctionURL = void 0;
const analytics_signals_runtime_1 = require("@segment/analytics-signals-runtime");
const analytics_signals_runtime_2 = require("@segment/analytics-signals-runtime");
const load_script_1 = require("../../lib/load-script");
const logger_1 = require("../../lib/logger");
const replace_base_url_1 = require("../../lib/replace-base-url");
const workerbox_1 = require("../../lib/workerbox");
const polyfills_1 = require("./polyfills");
const sandbox_analytics_runtime_1 = require("./sandbox-analytics-runtime");
class JavascriptSandbox {
    constructor() {
        this.workerbox = (0, workerbox_1.createWorkerBox)();
    }
    async run(fn, scope) {
        try {
            const wb = await this.workerbox;
            await wb.run(fn, scope);
        }
        catch (err) {
            console.error("processSignal() error in sandbox", err, {
                fn,
            });
        }
    }
    async destroy() {
        const wb = await this.workerbox;
        await wb.destroy();
    }
}
const normalizeEdgeFunctionURL = (functionHost, edgeFnDownloadURL) => {
    if (functionHost && edgeFnDownloadURL) {
        (0, replace_base_url_1.replaceBaseUrl)(edgeFnDownloadURL, `https://${functionHost}`);
    }
    else {
        return edgeFnDownloadURL;
    }
};
exports.normalizeEdgeFunctionURL = normalizeEdgeFunctionURL;
const consoleWarnProcessSignal = () => console.warn("processSignal is not defined - have you set up auto-instrumentation on app.segment.com?");
class IframeSandboxSettings {
    constructor(settings) {
        const fetch = settings.edgeFnFetchClient ?? globalThis.fetch;
        let processSignalNormalized = Promise.resolve(`globalThis.processSignal = function() {}`);
        if (settings.processSignal) {
            processSignalNormalized = Promise.resolve(settings.processSignal).then((str) => `globalThis.processSignal = ${str}`);
        }
        else if (settings.edgeFnDownloadURL) {
            processSignalNormalized = fetch(settings.edgeFnDownloadURL).then((res) => res.text());
        }
        else {
            consoleWarnProcessSignal();
        }
        this.processSignal = processSignalNormalized;
    }
}
exports.IframeSandboxSettings = IframeSandboxSettings;
class WorkerSandbox {
    constructor(settings) {
        this.settings = settings;
        this.jsSandbox = new JavascriptSandbox();
    }
    async execute(signal, signals) {
        const analytics = new sandbox_analytics_runtime_1.AnalyticsRuntime();
        const scope = {
            analytics,
        };
        logger_1.logger.debug("processing signal", { signal, scope, signals });
        const code = [
            polyfills_1.polyfills,
            await this.settings.processSignal,
            (0, analytics_signals_runtime_2.getRuntimeCode)(),
            `signals.signalBuffer = ${JSON.stringify(signals)};`,
            "try { processSignal(" +
                JSON.stringify(signal) +
                ', { analytics, signals }); } catch(err) { console.error("Process signal failed.", err); }',
        ].join("\n");
        await this.jsSandbox.run(code, scope);
        const calls = analytics.getCalls();
        return calls;
    }
    destroy() {
        void this.jsSandbox.destroy();
    }
}
exports.WorkerSandbox = WorkerSandbox;
// ProcessSignal unfortunately uses globals. This should change.
// For now, we are setting up the globals between each invocation
const processWithGlobalScopeExecutionEnv = (signal, signalBuffer) => {
    const g = globalThis;
    const processSignal = g["processSignal"];
    if (typeof processSignal == "undefined") {
        consoleWarnProcessSignal();
        return undefined;
    }
    // processSignal expects a global called `signals` -- of course, there can local variable naming conflict on the client, which is why globals were a bad idea.
    const analytics = new sandbox_analytics_runtime_1.AnalyticsRuntime();
    const signals = new analytics_signals_runtime_1.WebSignalsRuntime(signalBuffer);
    const originalAnalytics = g.analytics;
    if (originalAnalytics instanceof sandbox_analytics_runtime_1.AnalyticsRuntime) {
        throw new Error("Invariant: analytics variable was not properly restored on the previous execution. This indicates a concurrency bug");
    }
    const originalSignals = g.signals;
    try {
        g["analytics"] = analytics;
        g["signals"] = signals;
        processSignal(signal, {
            // we eventually want to get rid of globals and processSignal just uses local variables.
            // TODO: update processSignal generator to accept params like these for web (mobile currently uses globals for their architecture -- can be changed but hard).
            analytics: analytics,
            signals: signals,
            // constants
        });
    }
    finally {
        // restore globals
        g["analytics"] = originalAnalytics;
        g["signals"] = originalSignals;
    }
    return analytics.getCalls();
};
class GlobalScopeSandbox {
    constructor(settings) {
        logger_1.logger.debug("Initializing global scope sandbox");
        this.htmlScriptLoaded = (0, load_script_1.loadScript)(settings.edgeFnDownloadURL);
    }
    async execute(signal, signals) {
        await this.htmlScriptLoaded;
        return processWithGlobalScopeExecutionEnv(signal, signals);
    }
    destroy() { }
}
exports.GlobalScopeSandbox = GlobalScopeSandbox;
class NoopSandbox {
    execute(_signal, _signals) {
        return Promise.resolve(undefined);
    }
    destroy() { }
}
exports.NoopSandbox = NoopSandbox;
//# sourceMappingURL=sandbox.js.map