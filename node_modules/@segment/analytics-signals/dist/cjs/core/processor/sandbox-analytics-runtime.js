"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnalyticsRuntime = void 0;
/**
 * Proxy around the analytics client
 */
class AnalyticsRuntime {
    constructor() {
        this.calls = {
            page: [],
            identify: [],
            track: [],
            alias: [],
            screen: [],
            group: [],
            reset: [],
        };
        // these methods need to be bound to the instance, rather than the prototype, in order to serialize correctly in the sandbox.
        this.track = (...args) => {
            const [name, properties, context] = args;
            try {
                this.calls.track.push([name, properties, this.createOptions(context)]);
            }
            catch (err) {
                // wrapping all methods in a try/catch because throwing an error won't cause the error to surface inside of workerboxjs
                console.error(err);
            }
        };
        this.identify = (...args) => {
            try {
                // @ts-ignore
                const [id, traits, context] = args;
                this.calls.identify.push([id, traits, this.createOptions(context)]);
            }
            catch (err) {
                console.error(err);
            }
        };
        this.alias = (...args) => {
            try {
                const [userId, previousId, context] = args;
                this.calls.alias.push([userId, previousId, this.createOptions(context)]);
            }
            catch (err) {
                console.error(err);
            }
        };
        this.group = (...args) => {
            try {
                // @ts-ignore
                const [id, traits, context] = args;
                this.calls.group.push([id, traits, this.createOptions(context)]);
            }
            catch (err) {
                console.error(err);
            }
        };
        this.page = (...args) => {
            try {
                const [name, category, props, context] = args;
                // If name is not provided, but category is, we default to an empty string
                // This is a legacy behavior from the argument resolver
                const nameStr = !name && category ? "" : name;
                this.calls.page.push([
                    category,
                    nameStr,
                    props,
                    this.createOptions(context),
                ]);
            }
            catch (err) {
                console.error(err);
            }
        };
        this.screen = (...args) => {
            try {
                const [name, category, props, context] = args;
                const nameStr = !name && category ? "" : name;
                this.calls.screen.push([
                    category,
                    nameStr,
                    props,
                    this.createOptions(context),
                ]);
            }
            catch (err) {
                console.error(err);
            }
        };
        this.reset = () => {
            this.calls.reset.push([]);
        };
    }
    getCalls() {
        return this.calls;
    }
    /**
     * Stamp the context with the event origin to prevent infinite signal-event loops.
     */
    createOptions(context) {
        return {
            context: { ...context, __eventOrigin: { type: "Signal" } },
        };
    }
}
exports.AnalyticsRuntime = AnalyticsRuntime;
//# sourceMappingURL=sandbox-analytics-runtime.js.map